#pragma once

#include <functional>
#include <utility>
#include <cstddef>
#include <iterator>
#include <cstdint>
#include <iostream>

enum {
    RED,
    BLACK,
};

enum BalanceType {
    DELETION,
    INSERTION,
};

template<typename T>
struct SetNode {
    T data;
    SetNode *left;
    SetNode *right;
    SetNode *parent;
    int8_t color;

    SetNode();
    explicit SetNode(const T& data);
    explicit SetNode(T&& data);
    explicit SetNode(const SetNode& node) = default;
    explicit SetNode(SetNode&& node) = default;

    SetNode& operator=(SetNode&& node) = default;

    T& get_data();
};

template<typename T>
class SetIterator : public std::iterator<std::bidirectional_iterator_tag, T, std::ptrdiff_t, T*, T&> {
public:
    SetIterator(SetNode<T>* rhs = nullptr) : ptr(rhs) {}
    SetIterator(const SetIterator<T>& rhs) = default;
    SetIterator<T>& operator=(const SetIterator<T>& rhs) = default;
    SetIterator<T>& operator=(SetNode<T>* rhs) {
        this->ptr = rhs;
        return *this;
    }
    bool operator==(const SetIterator<T>& rhs) const {
        return this->ptr == rhs.ptr;
    }
    bool operator!=(const SetIterator<T>& rhs) const {
        return !(*this == rhs);
    }
    T& operator*() {
        return this->ptr->data;
    }
    const T& operator*() const {
        return this->ptr->data;
    }
    T* operator->() {
        return &(this->ptr->data);
    }
    /*Inorder successor algorithm*/
    SetIterator<T> operator++() {
        if (this->ptr == nullptr) {
            return SetIterator<T>();
        }
        SetNode<T>* current;
        if (this->ptr->right) {
            current = this->ptr->right;
            while (current->left != nullptr) {
                current = current->left;
            }
        }
        else {
            current = this->ptr->parent;
            while (current != nullptr && this->ptr == current->right) {
                this->ptr = current;
                current = current->parent;
            }
        }

        this->ptr = current;
        return *this;
    }
    SetIterator<T> operator++(int) {
        if (this->ptr == nullptr) {
            return SetIterator<T>();
        }

        SetIterator<T> tmp(*this);
        SetNode<T>* current;
        if (this->ptr->right) {
            current = this->ptr->right;
            while (current->left != nullptr) {
                current = current->left;
            }
        }
        else {
            current = this->ptr->parent;
            while (current != nullptr && this->ptr == current->right) {
                this->ptr = current;
                current = current->parent;
            }
        }

        this->ptr = current;
        return tmp;
    }
    /*Inorder predecessor algorithm*/
    SetIterator<T>& operator--() {
        if (this->ptr == nullptr) {
            return SetIterator<T>();
        }

        SetNode<T>* current;
        if (this->ptr->left) {
            current = this->ptr->left;
            while (current->right != nullptr) {
                current = current->right;
            }
        }
        else {
            current = this->ptr->parent;
            while (current != nullptr && this->ptr == current->left) {
                this->ptr = current;
                current = current->parent;
            }
        }

        this->ptr = current;
        return *this;
    }
    SetIterator<T> operator--(int) {
        if (this->ptr == nullptr) {
            return SetIterator<T>();
        }

        SetIterator<T> tmp(*this);

        SetNode<T>* current;
        if (this->ptr->left) {
            current = this->ptr->left;
            while (current->right != nullptr) {
                current = current->right;
            }
        }
        else {
            current = this->ptr->parent;
            while (current != nullptr && this->ptr == current->left) {
                this->ptr = current;
                current = current->parent;
            }
        }

        this->ptr = current;
        return tmp;
    }
    void swap(SetIterator<T>& lhs, SetIterator<T>& rhs) {
        std::swap(lhs, rhs);
    }

    void setPtr(SetNode<T>* ptr) {
        this->ptr = ptr;
    }

    SetNode<T>* getPtr() {
        return this->ptr;
    }

    const SetNode<T>* getPtr() const {
        return this->ptr;
    }

private:
    SetNode<T>* ptr;
};


#define parent_of(node) _parent_of(node)

template<typename T>
static inline SetNode<T>* _parent_of(SetNode<T>* node) {
    return node ? node->parent : nullptr;
}

#define grandparent_of(node) _grandparent_of(node)

template<typename T>
static inline SetNode<T>* _grandparent_of(SetNode<T>* node) {
    if (node) {
        if (node->parent) {
            return node->parent->parent;
        }
    }
    return nullptr;
}

template<typename T>
static inline SetNode<T>* left_of(SetNode<T> *node) {
    return node ? node->left : nullptr;
}

template<typename T>
static inline SetNode<T>* right_of(SetNode<T> *node) {
    return node ? node->right : nullptr;
}

#define assign_color(node, color) _set_color(node, color)

template<typename T>
static inline void _set_color(SetNode<T> *node, char color) {
    if (node) {
        node->color = color;
    }
}

#define color_of(node) _color_of(node)

template<typename T>
static inline char _color_of(SetNode<T> *node) {
    return node ? node->color : (int8_t) BLACK;
}

#define balance_insertion(side, rotate_1, rotate_2)                 \
    do  {                                                           \
            {                                                       \
                SetNode<T> *uncle = side(grandparent_of(node));     \
                                                                    \
                if (color_of(uncle) == RED) {                       \
                    /*Uncle RED means color-flip*/                  \
                                                                    \
                    assign_color(parent_of(node), BLACK);           \
                    assign_color(grandparent_of(node), RED);        \
                    assign_color(uncle, BLACK);                     \
                    node = grandparent_of(node);                    \
                }                                                   \
                else {                                              \
                    /*Uncle BLACK means rotations*/                 \
                    if (node == side(parent_of(node))) {            \
                        node = parent_of(node);                     \
                        rotate_2(node);                             \
                    }                                               \
                    assign_color(parent_of(node), BLACK);           \
                    assign_color(grandparent_of(node), RED);        \
                    rotate_1(grandparent_of(node));                 \
                }                                                   \
            }                                                       \
    } while(0)

#define balance_deletion(side1, side2, rotate_side1, rotate_side2)   \
    do {                                                             \
            {                                                        \
                SetNode<T>* sibling = side1(parent_of(node));        \
                if (color_of(sibling) == RED) {                      \
                    assign_color(sibling, BLACK);                    \
                    assign_color(parent_of(node), RED);              \
                    rotate_side1(parent_of(node));                   \
                    sibling = side1(parent_of(node));                \
                }                                                    \
                if (color_of(side2(sibling)) == BLACK && color_of(side1(sibling)) == BLACK) { \
                    assign_color(sibling, RED);                      \
                    node = parent_of(node);                          \
                }                                                    \
                else {                                               \
                    if (color_of(side1(sibling)) == BLACK) {         \
                        assign_color(side2(sibling), BLACK);         \
                        assign_color(sibling, RED);                  \
                        rotate_side2(sibling);                       \
                        sibling = side1(parent_of(node));            \
                    }                                                \
                    assign_color(sibling, color_of(parent_of(node)));\
                    assign_color(parent_of(node), BLACK);            \
                    assign_color(side1(sibling), BLACK);             \
                    rotate_side1(parent_of(node));                   \
                    node = this->root;                               \
                }                                                    \
            }                                                        \
    } while(0)

template<typename T, class Less = std::less<T>>
class Set {
private:
    SetNode<T> *root;
    SetNode<T> *endNode;
    Less less;
    size_t _size;
    void rotate_left(SetNode<T> *);
    void rotate_right(SetNode<T> *);
    SetNode<T>* bst_insert(bool&, const T&);
    SetNode<T>* bst_insert(bool&, T&&);
    SetNode<T>* _copy_tree(SetNode<T>*);
    SetNode<T>* _remove(SetNode<T> *, SetNode<T>*);
    void restore_balance(SetNode<T>*, int8_t type);
    void tree_destroy(SetNode<T> *);
public:
    //TODO: implement const version of this class (const_iterators etc)
    Set() noexcept;
    Set(const Set& rhs) noexcept;
    Set(Set&& rhs) noexcept;
    ~Set();

    Set& operator=(Set x);
    bool add(const T& data);
    bool add(T&& data);
    bool remove(const T& key);
    SetIterator<T> remove(SetIterator<T> itr);
    void clear() noexcept;
    void clear() const noexcept;
    
    bool empty();
    size_t size();

    SetIterator<T> begin();
    SetIterator<T> end();
    SetIterator<T> search(const T& key);

    friend void swap(Set& lhs, Set& rhs) {
        using std::swap;

        swap(lhs.root, rhs.root);
        swap(lhs.endNode, rhs.endNode);
        swap(lhs.less, rhs.less);
        swap(lhs._size, rhs._size);   
    }
};

/*Implementation*/
template<typename T, class Less>
Set<T, Less>::Set() noexcept : root(nullptr), endNode(nullptr) , _size(0) {}

template<typename T, class Less>
SetNode<T>* Set<T, Less>::_copy_tree(SetNode<T>* other_root) {
    if (other_root == nullptr) {
        return nullptr;
    }

    SetNode<T>* new_node = new SetNode<T>(other_root->data);
    
    new_node->left = _copy_tree(other_root->left);
    if (new_node->left) {
        new_node->left->parent = new_node;
    }

    new_node->right = _copy_tree(other_root->right);
    if (new_node->right) {
        new_node->right->parent = new_node;   
    }

    return new_node;
}

template<typename T, class Less>
Set<T, Less>::Set(const Set& other) noexcept {
    /*Create an exact copy of this set, O(n)*/
    this->root = _copy_tree(other.root);
    this->endNode = new SetNode<T>();
    this->endNode->left = this->root;
    this->root->parent = this->endNode;
}

template<typename T, class Less>
Set<T, Less>::Set(Set&& other) noexcept : Set() {
    swap(*this, other);
}

template<typename T, class Less>
Set<T, Less>& Set<T, Less>::operator=(Set other) {
    /*Copy and swap idiom, let the compiler handle the copy of the argument*/
    swap(*this, other);

    return *this;
}

template<typename T, class Less>
void Set<T, Less>::tree_destroy(SetNode<T> *current) {

    if (!current) {
        return;
    }

    tree_destroy(current->left);
    tree_destroy(current->right);

    delete current;
}

template<typename T, class Less>
Set<T, Less>::~Set() {
    if (this->root) {
        tree_destroy(this->root);
        delete this->endNode;
    }
}

template<typename T, class Less>
SetNode<T> *Set<T, Less>::bst_insert(bool &added_new, const T &data) {

    if (empty()) {
        added_new = true;
        this->root = new SetNode<T>(data);
        this->endNode = new SetNode<T>();
        this->endNode->left = this->root;
        this->root->parent = this->endNode;
        return this->root;
    }

    SetNode<T> *current = this->root;
    while (1) {

        if (less(data, current->data)) {
            if (current->left != nullptr) {
                current = current->left;
            }
            else {
                added_new = true;
                SetNode<T> *new_node = new SetNode<T>(data);
                current->left = new_node;
                new_node->parent = current;

                return new_node;
            }
        }
        else if (less(current->data, data)) {
            if (current->right != nullptr) {
                current = current->right;
            }
            else {
                added_new = true;
                SetNode<T> *new_node = new SetNode<T>(data);
                current->right = new_node;
                new_node->parent = current;

                return new_node;
            }
        }
        else {
            added_new = false;
            return current;
        }
    }
}

template<typename T, class Less>
SetNode<T> *Set<T, Less>::bst_insert(bool &added_new, T &&data) {

    if (empty()) {
        added_new = true;
        this->root = new SetNode<T>(std::forward<T>(data));
        this->endNode = new SetNode<T>();
        this->endNode->left = this->root;
        this->root->parent = this->endNode;
        return this->root;
    }

    SetNode<T> *current = this->root;
    while (1) {

        if (less(data, current->data)) {
            if (current->left != nullptr) {
                current = current->left;
            }
            else {
                added_new = true;
                SetNode<T> *new_node = new SetNode<T>(std::forward<T>(data));
                current->left = new_node;
                new_node->parent = current;

                return new_node;
            }
        }
        else if (less(current->data, data)) {
            if (current->right != nullptr) {
                current = current->right;
            }
            else {
                added_new = true;
                SetNode<T> *new_node = new SetNode<T>(std::forward<T>(data));
                current->right = new_node;
                new_node->parent = current;

                return new_node;
            }
        }
        else {
            added_new = false;
            return current;
        }
    }
}

template<typename T, class Less>
bool Set<T, Less>::add(const T &data) {

    bool added_new;
    SetNode<T> *current = bst_insert(added_new, data);

    if (!added_new) {
        return false;
    }

    restore_balance(current,INSERTION);

    this->root->color = BLACK;
    this->_size++;
    this->endNode->left = this->root;
    this->root->parent = this->endNode;

    return true;
}

template<typename T, class Less>
bool Set<T, Less>::add(T &&data) {

    bool added_new;
    SetNode<T> *current = bst_insert(added_new, std::forward<T>(data));

    if (!added_new) {
        return false;
    }

    restore_balance(current,INSERTION);

    this->root->color = BLACK;
    this->_size++;   
    this->root->parent = this->endNode;
    this->endNode->left = this->root;

    return true;
}

template<typename T, class Less>
void Set<T, Less>::clear() noexcept {
    if (this->root) {
        tree_destroy(this->root);
        delete this->endNode;
        this->root = nullptr;
        this->endNode = nullptr;
        this->_size = 0;
    }
}

template<typename T, class Less>
void Set<T, Less>::clear() const noexcept {
    if (this->root) {
        tree_destroy(this->root);
        delete this->endNode;
        this->root = nullptr;
        this->endNode = nullptr;
        this->_size = 0;
    }
}

template<typename T, class Less>
bool Set<T, Less>::empty() {
    return this->root == nullptr;
}


template<typename T, class Less>
void Set<T, Less>::restore_balance(SetNode<T>* node, int8_t type) {

    if (type == DELETION) {
        while (node != this->root && color_of(node) == BLACK) {
            if (node == left_of(parent_of(node))) {
                balance_deletion(right_of, left_of, rotate_left, rotate_right);
            }
            else {
                balance_deletion(left_of, right_of, rotate_right, rotate_left);
            }
        }

        if (node != nullptr && color_of(node) != BLACK) {
            assign_color(node, BLACK);
        }
    }   
    else if (type == INSERTION) {
        node->color = RED;
        this->root->parent = nullptr;

        while (node != endNode && node != this->root) {
            if (node->parent->color != RED) {
                break;
            }

            if (parent_of(node) == left_of(grandparent_of(node))) {
                balance_insertion(right_of, rotate_right, rotate_left);
            }
            else {
                balance_insertion(left_of, rotate_left, rotate_right);
            }
        }
    }
    else {
        throw std::invalid_argument("This should not have happened, pls debug me :)");
    }
}

template<typename T, class Less>
SetNode<T>* Set<T, Less>::_remove(SetNode<T>* current, SetNode<T>* successor) {

    /*If this node is not a leaf and has both children*/
    if (current->left != nullptr && current->right != nullptr) {
        /*Get the minimum value of the right subtree*/
        current->data = successor->data;
        current = successor;
    }

    SetNode<T>* r_node = current->left != nullptr ? current->left : current->right;

    /*If node has one children*/
    if (r_node != nullptr) {
        r_node->parent = current->parent;
        SetNode<T>* parent_node = current->parent;
        if (parent_node == nullptr) {
            this->root = r_node;
        }
        else if (current == parent_node->left) {
            parent_node->left = r_node;
        }
        else {
            parent_node->right = r_node;
        }

        current->right = nullptr;
        current->left = nullptr;
        current->parent = nullptr;

        if (color_of(current) == BLACK) {
            /*Balance only if its a black node*/
           // restore_balance(r_node, DELETION);
        }
    }
    else if (current->parent == nullptr) {
        this->_size = 0;
        delete this->root;
        delete this->endNode;
        this->root = nullptr;
        this->endNode = nullptr; 
        return this->root;
    }
    else {
        /*Its a leaf*/
        if (color_of(current) == BLACK) {
            /*Balance only if its a black node*/
           // restore_balance(current, DELETION);
        }

        SetNode<T>* parent_node = current->parent;
        if (parent_node != nullptr) {
            if (current == parent_node->left) {
                parent_node->left = nullptr;
            }
            else if (current == parent_node->right) {
                parent_node->right = nullptr;
            }
            current->parent = nullptr;
        }
    }

    return current;
}

template<typename T, class Less>
SetIterator<T> Set<T, Less>::begin() {
    SetNode<T> *current = this->root;
    if (current == nullptr) {
        return SetIterator<T>();
    }
    while (current->left != nullptr) {
        current = current->left;
    }

    return SetIterator<T>(current);
}

template<typename T, class Less>
SetIterator<T> Set<T, Less>::end() {
    return SetIterator<T>(this->endNode);
}


template<typename T, class Less>
bool Set<T, Less>::remove(const T &key) {
    
    SetNode<T>* current = nullptr;
    auto result = search(key);
    
    if (result == end()) {
        return false;
    } 

    SetNode<T>* save = this->endNode;
    this->root->parent = nullptr;
    
    SetNode<T>* successor =  (++SetIterator<T>(result)).getPtr();
    current = _remove(result.getPtr(), successor);
    
    if (current != nullptr) {
        delete current;
        current = nullptr;

        /*Update the secret node*/
        this->endNode = save;
        this->root->parent = this->endNode;
        this->endNode->left = this->root;
        this->_size--;
    }

    return true;
}

template<typename T, class Less>
SetIterator<T> Set<T, Less>::remove(SetIterator<T> itr) {

    if (itr == end()) {
        return itr;
    }

    SetNode<T>* save = this->endNode;
    this->root->parent = nullptr;

    SetNode<T>* prev_current = itr.getPtr();
    SetNode<T>* successor =  (++SetIterator<T>(itr)).getPtr();
    SetNode<T>* current = _remove(itr.getPtr(), successor);
    
    if (current != nullptr) {
        SetIterator<T> retrnValue(current == successor ? itr.getPtr() : successor);
        
        delete current;
        current = nullptr;

        /*Update the secret node*/
        this->endNode = save;
        this->root->parent = this->endNode;
        this->endNode->left = this->root;
        this->_size--;
        
        if (successor != nullptr) {
            return retrnValue;
        }
        else {
            return this->end();
        }
    }

    return this->end();
}

template<typename T, class Less>
SetIterator<T> Set<T, Less>::search(const T &val) {

    if (this->root == nullptr) {
        return this->end();
    }
    SetNode<T> *current = this->root;
    while (current) {
        if (less(val, current->data)) {
            current = current->left;
        }
        else if (less(current->data, val)) {
            current = current->right;
        }
        else {
            return SetIterator<T>(current);
        }
    }

    return this->end();
}

template<typename T, class Less>
void Set<T, Less>::rotate_right(SetNode<T> *node) {

    if (!node) {
        return;
    }

    SetNode<T> *left_child = node->left;
    SetNode<T> *left_right_child = left_child->right;

    node->left = left_right_child;
    if (left_right_child) {
        left_right_child->parent = node;
    }

    SetNode<T> *node_p = node->parent;
    left_child->parent = node_p;

    if (node_p == nullptr) {
        this->root = left_child;
    }
    else if (node_p->right == node) {
        node_p->right = left_child;
    }
    else {
        node_p->left = left_child;
    }

    left_child->right = node;
    node->parent = left_child;
}

template<typename T, class Less>
void Set<T, Less>::rotate_left(SetNode<T> *node) {

    if (!node) {
        return;
    }

    SetNode<T> *right_child = node->right;
    SetNode<T> *right_left_child = right_child->left;

    node->right = right_left_child;
    if (right_left_child) {
        right_left_child->parent = node;
    }

    SetNode<T>  *node_p = node->parent;
    right_child->parent = node_p;

    if (node_p == nullptr) {
        this->root = right_child;
    }
    else if (node_p->left == node) {
        node_p->left = right_child;
    }
    else {
        node_p->right = right_child;
    }

    right_child->left = node;
    node->parent = right_child;
}

template<typename T, class Less>
size_t Set<T, Less>::size() {
    return this->_size;
}

template<typename T>
SetNode<T>::SetNode() : data(0), left(nullptr), right(nullptr), parent(nullptr), color(RED) {}

template<typename T>
SetNode<T>::SetNode(const T &val) : data(val), left(nullptr), right(nullptr), parent(nullptr), color(RED) {}

template<typename T>
SetNode<T>::SetNode(T &&val) : data(std::forward<T>(val)), left(nullptr), right(nullptr), parent(nullptr), color(RED) {}

template<typename T>
T& SetNode<T>::get_data() {
    return this->data;
}


